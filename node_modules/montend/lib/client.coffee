###*!
* Copyright(c) 2012 vicanso 腻味
* MIT Licensed
###

_ = require 'underscore'
mongodb = require 'mongodb'
url = require 'url'
crypto = require 'crypto'
QueryCache = require './querycache'
logger = console
noop = () ->

class Client
  constructor : (redisClient) ->
    @dbs = {}
    @collections = {}
    @cacheObj = new QueryCache redisClient
    queryCache @cacheObj
  logQueryTime : () ->
    logQueryTime()
  queryCache : (redisClient) ->
    @cacheObj.redisClient redisClient
  setLogger : (log) ->
    logger = log
  disableLog : () ->
    logger = 
      info : noop
      error : noop
      warn : noop
  db : (dbName, db) ->
    self = @
    if db
      @dbs[dbName] = db
      return self
    else
      return @dbs[dbName]
  handle : (dbName, collectionName, handleName, args...) ->
    self = @
    cacheObj = self.cacheObj
    se = serializationQuery _.toArray arguments
    key = cacheObj.key se, handleName
    originCbf = args.pop()
    cbf = (err, data) ->
      if data && _.isFunction data.toArray
        data.toArray (err, data) ->
          if data
            cacheObj.set key, data, 60
          originCbf err, data
      else
        cacheObj.set key, data, 60
        originCbf err, data
    args.push cbf
    self.collection dbName, collectionName, (err, collectionObj) ->
      if err
        cbf err
      else
        collectionObj[handleName].apply collectionObj, args
  collection : (dbName, collectionName, cbf) ->
    self = @
    collectionKey = "#{dbName}_#{collectionName}"
    if !_.isFunction cbf
      collectionObj = cbf
      self.collections[collectionKey] = collectionObj
      return self
    else
      collectionObj = self.collections[collectionKey]
      if collectionObj
        cbf null, collectionObj
      else
        db = self.db dbName
        if db
          db.collection collectionName, (err, collectionObj) ->
            if err
              cbf err
            else
              self.collection dbName, collectionName, collectionObj
              cbf null, collectionObj
        else
          cbf new Error "The db #{dbName} is not init"
  init : (uri, options = {safe : false}, cbf = noop) ->
    self = @
    uris = uri.split ','
    connectionInfos = {}
    _.each uris, (uri) ->
      uri = url.parse uri
      db = uri.path.substring 1
      if db
        if !connectionInfos[db]
          connectionInfos[db] = []
        connectionInfos[db].push {
          host : uri.hostname
          port : GLOBAL.parseInt uri.port || 47017
        }
    initializingTotal = 0
    _.each connectionInfos, (value, dbName) ->
      if !self.db dbName
        serverOptions = _.pick options, ['poolSize']
        server = self.getServer value, serverOptions
        db = new mongodb.Db dbName, server, _.omit options, ['poolSize']
        initializingTotal++
        db.open (err, db) ->
          initializingTotal--
          if err
            cbf err
          else
            self.db dbName, db
            if initializingTotal == 0
              cbf null
    if initializingTotal == 0
      cbf null
    return self
  getServer : (infos, options) ->
    defaults = 
      poolSize : 8
    _.extend defaults, options
    servers = _.map infos, (info) ->
      return new mongodb.Server info.host, info.port, options
    if servers.length > 1
      return new mongodb.ReplSetServers servers
    else
      return servers[0]

serializationQuery = (args) ->
  serializationList = []
  _.each args, (arg) ->
    if! _.isFunction arg
      if _.isString arg
        serializationList.push arg
      else
        serializationList.push JSON.stringify arg
  return serializationList.join ','
  # return crypto.createHash('sha1').update(se).digest 'hex'


queryCache = (cacheObj) ->
  cacheObj.setCacheFunctions 'find findOne findById count'
  Client.prototype.handle = _.wrap Client.prototype.handle, (func, args...) ->
    self = @
    se = serializationQuery args
    key = cacheObj.key se, args[2]
    if !key
      func.apply self, args
    else
      cbf = args[args.length - 1]
      cacheObj.get key, (err, data) ->
        if !err && data
          cbf null, data
        else
          func.apply self, args

logQueryTime = () ->
  Client.prototype.handle = _.wrap Client.prototype.handle, (func, args...) ->
    se = serializationQuery args
    cbf = args.pop()
    start = Date.now()
    cbf = _.wrap cbf, (func, err, data) ->
      logger.info "#{se} use time:#{Date.now() - start}ms"
      func err, data
    args.push cbf
    func.apply @, args

# _.extend Client, hooks
# Client.pre 'handle', true, (next, done) ->
#   console.log 'pre'
#   console.log serializationArgs _.toArray arguments
#   next()
# Client.post 'handle', (next) ->
#   console.log 'finished'
#   next()
module.exports = Client